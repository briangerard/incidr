#!/usr/bin/env python

'''
Shows an IP or IPs, optionally masked, in various formats.

Example:
$ incidr 1.2.3.4/24
1.2.3.4/24 :
==========
      1.  2.  3.  4  <=>  00000001 00000010 00000011 00000100  <=>  01020304  <=>  0016909060
 &  255.255.255.  0  <=>  11111111 11111111 11111111 00000000  <=>  ffffff00  <=>  4294967040
 =    1.  2.  3.  0  <=>  00000001 00000010 00000011 00000000  <=>  01020300  <=>  0016909056
'''

import argparse
import re
import socket
import struct

class Net:
    '''
    A Net is just an IP address (only v4 right now), potentially with a netmask
    applied.
    '''

    def __init__(self, net, showQuad=True, showBin=True, showDec=True, showHex=True):
        '''
        Instantiate a Net, depending on what was passed in.
        '''
        self.orig   = net
        self.quad   = None
        self.mask   = None
        self.masked = None
        self.raw    = None

        # Specify how this Net is to be displayed.
        self.showQuad = showQuad
        self.showBin  = showBin
        self.showDec  = showDec
        self.showHex  = showHex

        # What was passed in - maybe a.b.c.d/m?
        if '/' in self.orig:
            # Max of one slash, mkay?
            if self.orig.count('/') > 1:
                raise ValueError('Invalid CIDR block (multiple "/"es): ' + self.orig)
            # Ok, looks good.
            else:
                self.quad, bits = self.orig.split('/')
                self.mask       = Net(bits2quad(bits), showQuad, showBin, showDec, showHex)
                self.raw        = socket.inet_aton(self.quad)
        
        # Or maybe an int of some sort...
        elif '.' not in self.orig:
            # A decimal number?
            if (len(self.orig) <= 10
                    and re.search(r'\d', self.orig) != None
                    and re.search(r'\D', self.orig) == None):
                base = 10
            # How about a hex string?
            elif (len(self.orig) <= 8
                    and re.search(r'(?i)[^0-9a-f]', self.orig) == None):
                base = 16
            # Right.  No clue what we were given.  Bailing.
            else:
                raise ValueError('Invalid CIDR block (invalid numeric value): ' + self.orig)

            self.raw  = socket.inet_aton(str(int(self.orig, base)))
            self.quad = socket.inet_ntoa(self.raw)

        # Alright, none of those - how about just a.b.c.d?
        # inet_aton() throws an OSError on bad input, which should be caught by
        # the caller.
        else:
            self.raw = socket.inet_aton(self.orig)
            self.quad = socket.inet_ntoa(self.raw)

        # Now to populate the various representations of the Net.  Not bothering
        # to check which format was requested - the translations just aren't that
        # expensive.
        #
        # NOTE: The reason for the struct.unpack call is to allow this to work in
        # both python2.x and python3.x
        self.as_dec = '{:010d}'.format(int(sum(256**(3-x)*struct.unpack('B', self.raw[x:x+1])[0] for x in range(4))))
        self.as_hex = '{:08x}'.format(int(self.as_dec))
        self.as_bin = ' '.join('{:08b}'.format(int(o)) for o in self.quad.split('.'))

        if self.mask:
            self.masked     = self & self.mask

    def __and__(self, other):
        '''
        Overloading '&' to apply a netmask.  That's really what's going on
        anyway, and it just makes sense.
        '''
        newnet = bytearray(socket.inet_aton('0.0.0.0'))

        # NOTE: Using struct.unpack so this works in both python2.x and python 3.x
        for o in range(4):
            newnet[o] = struct.unpack('B', self.raw[o:o+1])[0] & struct.unpack('B', other.raw[o:o+1])[0]

        # Inheriting the display formats from self.
        return Net(socket.inet_ntoa(bytes(newnet)), self.showQuad, self.showBin, self.showDec, self.showHex)

    def __str__(self):
        '''
        Return the translation of the IP (or netblock) as its various alternate formats,
        based on what the user requested.
        '''
        theStr = '  '
        
        if self.showQuad:
            theStr += '.'.join('{:>3}'.format(o) for o in self.quad.split('.'))
        if self.showBin:
            if re.search(r'\S', theStr):
                theStr += '  <=>  '
            theStr += self.as_bin
        if self.showHex:
            if re.search(r'\S', theStr):
                theStr += '  <=>  '
            theStr += self.as_hex
        if self.showDec:
            if re.search(r'\S', theStr):
                theStr += '  <=>  '
            theStr += self.as_dec

        if self.mask:
            theStr = '  ' + theStr
            theStr += '\n' + ' &' + str(self.mask)
        if self.masked:
            theStr += '\n' + ' =' + str(self.masked)

        return theStr

def bits2quad(mask):
    """
    Change, for example, 24 into 255.255.255.0
    NOTE: Currently only v4; will need update for v6.
    """
    # TODO: Handle out-of-range masks a bit more explicitly.
    #       currently mask < 0 results in 0.0.0.0 and
    #       mask > 32 results in 255.255.255.255.  Not a
    #       terrible way to go, but we should probably throw
    #       at least a warning for a bad netmask.
    # TODO: Handle invalid masks (as in, utterly screwy
    #       masks, like 'bob').
    mask = int(mask)
    octets = []
    for o in range(4):
        if mask >= 8:
            octets.extend(['255'])
            mask -= 8
        elif mask > 0:
            octets.extend([str(int('1'*mask+'0'*(8-mask),2))])
            mask = 0
        else:
            octets.extend(['0'])
    return '.'.join(octets)


argparser = argparse.ArgumentParser(
                        description="Display v4 IPs and/or CIDR blocks in dotted-quad, binary, hex, and decimal.",
                        epilog='''You can specify any combination of the --quad, --binary, --decimal, and --hexadecimal
                        options together to get multiple formats.  The default is to show all of them.''')
argparser.add_argument('addresses',
                        nargs='+',
                        help='List of IPs or CIDR blocks to process.')
argparser.add_argument('--mask',
                        action='append',
                        help='The mask to apply the addresses.')
argparser.add_argument('--quad',
                        action='store_true',
                        help='Only display the addresses as dotted quads.')
argparser.add_argument('--binary',
                        action='store_true',
                        help='Only display the addresses as binary.')
argparser.add_argument('--decimal',
                        action='store_true',
                        help='Only display the addresses as base-10 ints.')
argparser.add_argument('--hexadecimal',
                        action='store_true',
                        help='Only display the addresses as hexadecimal ints.')
args = argparser.parse_args()

formats = []
if args.quad or args.binary or args.decimal or args.hexadecimal:
    formats = [ args.quad, args.binary, args.decimal, args.hexadecimal ]

for cidr in args.addresses:
    # Making this a list in case the user specifies multiple --mask's
    cidrs = []

    # If the user specifies --mask m and a bare address,
    # change the constructor arg to 'a.b.c.c/m'.
    if '/' not in cidr and args.mask:
        for mask in args.mask:
            cidrs.append(cidr + '/' + mask)
    # Otherwise, just pass on what we got.
    else:
        cidrs.append(cidr)

    for net in cidrs:
        print(net + " :")
        print('=' * len(net))

        try:
            thisNet = Net(net, *formats)
        except ValueError as v:
            print('Error: ' + str(v))
            print('Skipping')
            print('')
            continue
        except OSError as o:
            print('Error: ' + str(o))
            print('Skipping')
            print('')
            continue

        print(thisNet)
        print('')
